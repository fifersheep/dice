// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'player_selection_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$PlayerSelectionState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nameInvalid,
    required TResult Function(String name) nameAvailable,
    required TResult Function(String name) nameUnavailable,
    required TResult Function(String name) checkingName,
    required TResult Function(String name) nameChange,
    required TResult Function() playerCreated,
    required TResult Function(int id) playerExists,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? nameInvalid,
    TResult Function(String name)? nameAvailable,
    TResult Function(String name)? nameUnavailable,
    TResult Function(String name)? checkingName,
    TResult Function(String name)? nameChange,
    TResult Function()? playerCreated,
    TResult Function(int id)? playerExists,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nameInvalid,
    TResult Function(String name)? nameAvailable,
    TResult Function(String name)? nameUnavailable,
    TResult Function(String name)? checkingName,
    TResult Function(String name)? nameChange,
    TResult Function()? playerCreated,
    TResult Function(int id)? playerExists,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PlayerNameInvalid value) nameInvalid,
    required TResult Function(PlayerNameAvailable value) nameAvailable,
    required TResult Function(PlayerNameUnavailable value) nameUnavailable,
    required TResult Function(CheckingPlayerName value) checkingName,
    required TResult Function(PlayerNameChange value) nameChange,
    required TResult Function(PlayerCreated value) playerCreated,
    required TResult Function(PlayerExists value) playerExists,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(PlayerNameInvalid value)? nameInvalid,
    TResult Function(PlayerNameAvailable value)? nameAvailable,
    TResult Function(PlayerNameUnavailable value)? nameUnavailable,
    TResult Function(CheckingPlayerName value)? checkingName,
    TResult Function(PlayerNameChange value)? nameChange,
    TResult Function(PlayerCreated value)? playerCreated,
    TResult Function(PlayerExists value)? playerExists,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PlayerNameInvalid value)? nameInvalid,
    TResult Function(PlayerNameAvailable value)? nameAvailable,
    TResult Function(PlayerNameUnavailable value)? nameUnavailable,
    TResult Function(CheckingPlayerName value)? checkingName,
    TResult Function(PlayerNameChange value)? nameChange,
    TResult Function(PlayerCreated value)? playerCreated,
    TResult Function(PlayerExists value)? playerExists,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PlayerSelectionStateCopyWith<$Res> {
  factory $PlayerSelectionStateCopyWith(PlayerSelectionState value,
          $Res Function(PlayerSelectionState) then) =
      _$PlayerSelectionStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$PlayerSelectionStateCopyWithImpl<$Res>
    implements $PlayerSelectionStateCopyWith<$Res> {
  _$PlayerSelectionStateCopyWithImpl(this._value, this._then);

  final PlayerSelectionState _value;
  // ignore: unused_field
  final $Res Function(PlayerSelectionState) _then;
}

/// @nodoc
abstract class _$$PlayerNameInvalidCopyWith<$Res> {
  factory _$$PlayerNameInvalidCopyWith(
          _$PlayerNameInvalid value, $Res Function(_$PlayerNameInvalid) then) =
      __$$PlayerNameInvalidCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PlayerNameInvalidCopyWithImpl<$Res>
    extends _$PlayerSelectionStateCopyWithImpl<$Res>
    implements _$$PlayerNameInvalidCopyWith<$Res> {
  __$$PlayerNameInvalidCopyWithImpl(
      _$PlayerNameInvalid _value, $Res Function(_$PlayerNameInvalid) _then)
      : super(_value, (v) => _then(v as _$PlayerNameInvalid));

  @override
  _$PlayerNameInvalid get _value => super._value as _$PlayerNameInvalid;
}

/// @nodoc

class _$PlayerNameInvalid implements PlayerNameInvalid {
  const _$PlayerNameInvalid();

  @override
  String toString() {
    return 'PlayerSelectionState.nameInvalid()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PlayerNameInvalid);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nameInvalid,
    required TResult Function(String name) nameAvailable,
    required TResult Function(String name) nameUnavailable,
    required TResult Function(String name) checkingName,
    required TResult Function(String name) nameChange,
    required TResult Function() playerCreated,
    required TResult Function(int id) playerExists,
  }) {
    return nameInvalid();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? nameInvalid,
    TResult Function(String name)? nameAvailable,
    TResult Function(String name)? nameUnavailable,
    TResult Function(String name)? checkingName,
    TResult Function(String name)? nameChange,
    TResult Function()? playerCreated,
    TResult Function(int id)? playerExists,
  }) {
    return nameInvalid?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nameInvalid,
    TResult Function(String name)? nameAvailable,
    TResult Function(String name)? nameUnavailable,
    TResult Function(String name)? checkingName,
    TResult Function(String name)? nameChange,
    TResult Function()? playerCreated,
    TResult Function(int id)? playerExists,
    required TResult orElse(),
  }) {
    if (nameInvalid != null) {
      return nameInvalid();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PlayerNameInvalid value) nameInvalid,
    required TResult Function(PlayerNameAvailable value) nameAvailable,
    required TResult Function(PlayerNameUnavailable value) nameUnavailable,
    required TResult Function(CheckingPlayerName value) checkingName,
    required TResult Function(PlayerNameChange value) nameChange,
    required TResult Function(PlayerCreated value) playerCreated,
    required TResult Function(PlayerExists value) playerExists,
  }) {
    return nameInvalid(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(PlayerNameInvalid value)? nameInvalid,
    TResult Function(PlayerNameAvailable value)? nameAvailable,
    TResult Function(PlayerNameUnavailable value)? nameUnavailable,
    TResult Function(CheckingPlayerName value)? checkingName,
    TResult Function(PlayerNameChange value)? nameChange,
    TResult Function(PlayerCreated value)? playerCreated,
    TResult Function(PlayerExists value)? playerExists,
  }) {
    return nameInvalid?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PlayerNameInvalid value)? nameInvalid,
    TResult Function(PlayerNameAvailable value)? nameAvailable,
    TResult Function(PlayerNameUnavailable value)? nameUnavailable,
    TResult Function(CheckingPlayerName value)? checkingName,
    TResult Function(PlayerNameChange value)? nameChange,
    TResult Function(PlayerCreated value)? playerCreated,
    TResult Function(PlayerExists value)? playerExists,
    required TResult orElse(),
  }) {
    if (nameInvalid != null) {
      return nameInvalid(this);
    }
    return orElse();
  }
}

abstract class PlayerNameInvalid implements PlayerSelectionState {
  const factory PlayerNameInvalid() = _$PlayerNameInvalid;
}

/// @nodoc
abstract class _$$PlayerNameAvailableCopyWith<$Res> {
  factory _$$PlayerNameAvailableCopyWith(_$PlayerNameAvailable value,
          $Res Function(_$PlayerNameAvailable) then) =
      __$$PlayerNameAvailableCopyWithImpl<$Res>;
  $Res call({String name});
}

/// @nodoc
class __$$PlayerNameAvailableCopyWithImpl<$Res>
    extends _$PlayerSelectionStateCopyWithImpl<$Res>
    implements _$$PlayerNameAvailableCopyWith<$Res> {
  __$$PlayerNameAvailableCopyWithImpl(
      _$PlayerNameAvailable _value, $Res Function(_$PlayerNameAvailable) _then)
      : super(_value, (v) => _then(v as _$PlayerNameAvailable));

  @override
  _$PlayerNameAvailable get _value => super._value as _$PlayerNameAvailable;

  @override
  $Res call({
    Object? name = freezed,
  }) {
    return _then(_$PlayerNameAvailable(
      name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PlayerNameAvailable implements PlayerNameAvailable {
  const _$PlayerNameAvailable(this.name);

  @override
  final String name;

  @override
  String toString() {
    return 'PlayerSelectionState.nameAvailable(name: $name)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PlayerNameAvailable &&
            const DeepCollectionEquality().equals(other.name, name));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(name));

  @JsonKey(ignore: true)
  @override
  _$$PlayerNameAvailableCopyWith<_$PlayerNameAvailable> get copyWith =>
      __$$PlayerNameAvailableCopyWithImpl<_$PlayerNameAvailable>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nameInvalid,
    required TResult Function(String name) nameAvailable,
    required TResult Function(String name) nameUnavailable,
    required TResult Function(String name) checkingName,
    required TResult Function(String name) nameChange,
    required TResult Function() playerCreated,
    required TResult Function(int id) playerExists,
  }) {
    return nameAvailable(name);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? nameInvalid,
    TResult Function(String name)? nameAvailable,
    TResult Function(String name)? nameUnavailable,
    TResult Function(String name)? checkingName,
    TResult Function(String name)? nameChange,
    TResult Function()? playerCreated,
    TResult Function(int id)? playerExists,
  }) {
    return nameAvailable?.call(name);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nameInvalid,
    TResult Function(String name)? nameAvailable,
    TResult Function(String name)? nameUnavailable,
    TResult Function(String name)? checkingName,
    TResult Function(String name)? nameChange,
    TResult Function()? playerCreated,
    TResult Function(int id)? playerExists,
    required TResult orElse(),
  }) {
    if (nameAvailable != null) {
      return nameAvailable(name);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PlayerNameInvalid value) nameInvalid,
    required TResult Function(PlayerNameAvailable value) nameAvailable,
    required TResult Function(PlayerNameUnavailable value) nameUnavailable,
    required TResult Function(CheckingPlayerName value) checkingName,
    required TResult Function(PlayerNameChange value) nameChange,
    required TResult Function(PlayerCreated value) playerCreated,
    required TResult Function(PlayerExists value) playerExists,
  }) {
    return nameAvailable(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(PlayerNameInvalid value)? nameInvalid,
    TResult Function(PlayerNameAvailable value)? nameAvailable,
    TResult Function(PlayerNameUnavailable value)? nameUnavailable,
    TResult Function(CheckingPlayerName value)? checkingName,
    TResult Function(PlayerNameChange value)? nameChange,
    TResult Function(PlayerCreated value)? playerCreated,
    TResult Function(PlayerExists value)? playerExists,
  }) {
    return nameAvailable?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PlayerNameInvalid value)? nameInvalid,
    TResult Function(PlayerNameAvailable value)? nameAvailable,
    TResult Function(PlayerNameUnavailable value)? nameUnavailable,
    TResult Function(CheckingPlayerName value)? checkingName,
    TResult Function(PlayerNameChange value)? nameChange,
    TResult Function(PlayerCreated value)? playerCreated,
    TResult Function(PlayerExists value)? playerExists,
    required TResult orElse(),
  }) {
    if (nameAvailable != null) {
      return nameAvailable(this);
    }
    return orElse();
  }
}

abstract class PlayerNameAvailable implements PlayerSelectionState {
  const factory PlayerNameAvailable(final String name) = _$PlayerNameAvailable;

  String get name => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$PlayerNameAvailableCopyWith<_$PlayerNameAvailable> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PlayerNameUnavailableCopyWith<$Res> {
  factory _$$PlayerNameUnavailableCopyWith(_$PlayerNameUnavailable value,
          $Res Function(_$PlayerNameUnavailable) then) =
      __$$PlayerNameUnavailableCopyWithImpl<$Res>;
  $Res call({String name});
}

/// @nodoc
class __$$PlayerNameUnavailableCopyWithImpl<$Res>
    extends _$PlayerSelectionStateCopyWithImpl<$Res>
    implements _$$PlayerNameUnavailableCopyWith<$Res> {
  __$$PlayerNameUnavailableCopyWithImpl(_$PlayerNameUnavailable _value,
      $Res Function(_$PlayerNameUnavailable) _then)
      : super(_value, (v) => _then(v as _$PlayerNameUnavailable));

  @override
  _$PlayerNameUnavailable get _value => super._value as _$PlayerNameUnavailable;

  @override
  $Res call({
    Object? name = freezed,
  }) {
    return _then(_$PlayerNameUnavailable(
      name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PlayerNameUnavailable implements PlayerNameUnavailable {
  const _$PlayerNameUnavailable(this.name);

  @override
  final String name;

  @override
  String toString() {
    return 'PlayerSelectionState.nameUnavailable(name: $name)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PlayerNameUnavailable &&
            const DeepCollectionEquality().equals(other.name, name));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(name));

  @JsonKey(ignore: true)
  @override
  _$$PlayerNameUnavailableCopyWith<_$PlayerNameUnavailable> get copyWith =>
      __$$PlayerNameUnavailableCopyWithImpl<_$PlayerNameUnavailable>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nameInvalid,
    required TResult Function(String name) nameAvailable,
    required TResult Function(String name) nameUnavailable,
    required TResult Function(String name) checkingName,
    required TResult Function(String name) nameChange,
    required TResult Function() playerCreated,
    required TResult Function(int id) playerExists,
  }) {
    return nameUnavailable(name);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? nameInvalid,
    TResult Function(String name)? nameAvailable,
    TResult Function(String name)? nameUnavailable,
    TResult Function(String name)? checkingName,
    TResult Function(String name)? nameChange,
    TResult Function()? playerCreated,
    TResult Function(int id)? playerExists,
  }) {
    return nameUnavailable?.call(name);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nameInvalid,
    TResult Function(String name)? nameAvailable,
    TResult Function(String name)? nameUnavailable,
    TResult Function(String name)? checkingName,
    TResult Function(String name)? nameChange,
    TResult Function()? playerCreated,
    TResult Function(int id)? playerExists,
    required TResult orElse(),
  }) {
    if (nameUnavailable != null) {
      return nameUnavailable(name);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PlayerNameInvalid value) nameInvalid,
    required TResult Function(PlayerNameAvailable value) nameAvailable,
    required TResult Function(PlayerNameUnavailable value) nameUnavailable,
    required TResult Function(CheckingPlayerName value) checkingName,
    required TResult Function(PlayerNameChange value) nameChange,
    required TResult Function(PlayerCreated value) playerCreated,
    required TResult Function(PlayerExists value) playerExists,
  }) {
    return nameUnavailable(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(PlayerNameInvalid value)? nameInvalid,
    TResult Function(PlayerNameAvailable value)? nameAvailable,
    TResult Function(PlayerNameUnavailable value)? nameUnavailable,
    TResult Function(CheckingPlayerName value)? checkingName,
    TResult Function(PlayerNameChange value)? nameChange,
    TResult Function(PlayerCreated value)? playerCreated,
    TResult Function(PlayerExists value)? playerExists,
  }) {
    return nameUnavailable?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PlayerNameInvalid value)? nameInvalid,
    TResult Function(PlayerNameAvailable value)? nameAvailable,
    TResult Function(PlayerNameUnavailable value)? nameUnavailable,
    TResult Function(CheckingPlayerName value)? checkingName,
    TResult Function(PlayerNameChange value)? nameChange,
    TResult Function(PlayerCreated value)? playerCreated,
    TResult Function(PlayerExists value)? playerExists,
    required TResult orElse(),
  }) {
    if (nameUnavailable != null) {
      return nameUnavailable(this);
    }
    return orElse();
  }
}

abstract class PlayerNameUnavailable implements PlayerSelectionState {
  const factory PlayerNameUnavailable(final String name) =
      _$PlayerNameUnavailable;

  String get name => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$PlayerNameUnavailableCopyWith<_$PlayerNameUnavailable> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CheckingPlayerNameCopyWith<$Res> {
  factory _$$CheckingPlayerNameCopyWith(_$CheckingPlayerName value,
          $Res Function(_$CheckingPlayerName) then) =
      __$$CheckingPlayerNameCopyWithImpl<$Res>;
  $Res call({String name});
}

/// @nodoc
class __$$CheckingPlayerNameCopyWithImpl<$Res>
    extends _$PlayerSelectionStateCopyWithImpl<$Res>
    implements _$$CheckingPlayerNameCopyWith<$Res> {
  __$$CheckingPlayerNameCopyWithImpl(
      _$CheckingPlayerName _value, $Res Function(_$CheckingPlayerName) _then)
      : super(_value, (v) => _then(v as _$CheckingPlayerName));

  @override
  _$CheckingPlayerName get _value => super._value as _$CheckingPlayerName;

  @override
  $Res call({
    Object? name = freezed,
  }) {
    return _then(_$CheckingPlayerName(
      name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CheckingPlayerName implements CheckingPlayerName {
  const _$CheckingPlayerName(this.name);

  @override
  final String name;

  @override
  String toString() {
    return 'PlayerSelectionState.checkingName(name: $name)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CheckingPlayerName &&
            const DeepCollectionEquality().equals(other.name, name));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(name));

  @JsonKey(ignore: true)
  @override
  _$$CheckingPlayerNameCopyWith<_$CheckingPlayerName> get copyWith =>
      __$$CheckingPlayerNameCopyWithImpl<_$CheckingPlayerName>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nameInvalid,
    required TResult Function(String name) nameAvailable,
    required TResult Function(String name) nameUnavailable,
    required TResult Function(String name) checkingName,
    required TResult Function(String name) nameChange,
    required TResult Function() playerCreated,
    required TResult Function(int id) playerExists,
  }) {
    return checkingName(name);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? nameInvalid,
    TResult Function(String name)? nameAvailable,
    TResult Function(String name)? nameUnavailable,
    TResult Function(String name)? checkingName,
    TResult Function(String name)? nameChange,
    TResult Function()? playerCreated,
    TResult Function(int id)? playerExists,
  }) {
    return checkingName?.call(name);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nameInvalid,
    TResult Function(String name)? nameAvailable,
    TResult Function(String name)? nameUnavailable,
    TResult Function(String name)? checkingName,
    TResult Function(String name)? nameChange,
    TResult Function()? playerCreated,
    TResult Function(int id)? playerExists,
    required TResult orElse(),
  }) {
    if (checkingName != null) {
      return checkingName(name);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PlayerNameInvalid value) nameInvalid,
    required TResult Function(PlayerNameAvailable value) nameAvailable,
    required TResult Function(PlayerNameUnavailable value) nameUnavailable,
    required TResult Function(CheckingPlayerName value) checkingName,
    required TResult Function(PlayerNameChange value) nameChange,
    required TResult Function(PlayerCreated value) playerCreated,
    required TResult Function(PlayerExists value) playerExists,
  }) {
    return checkingName(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(PlayerNameInvalid value)? nameInvalid,
    TResult Function(PlayerNameAvailable value)? nameAvailable,
    TResult Function(PlayerNameUnavailable value)? nameUnavailable,
    TResult Function(CheckingPlayerName value)? checkingName,
    TResult Function(PlayerNameChange value)? nameChange,
    TResult Function(PlayerCreated value)? playerCreated,
    TResult Function(PlayerExists value)? playerExists,
  }) {
    return checkingName?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PlayerNameInvalid value)? nameInvalid,
    TResult Function(PlayerNameAvailable value)? nameAvailable,
    TResult Function(PlayerNameUnavailable value)? nameUnavailable,
    TResult Function(CheckingPlayerName value)? checkingName,
    TResult Function(PlayerNameChange value)? nameChange,
    TResult Function(PlayerCreated value)? playerCreated,
    TResult Function(PlayerExists value)? playerExists,
    required TResult orElse(),
  }) {
    if (checkingName != null) {
      return checkingName(this);
    }
    return orElse();
  }
}

abstract class CheckingPlayerName implements PlayerSelectionState {
  const factory CheckingPlayerName(final String name) = _$CheckingPlayerName;

  String get name => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$CheckingPlayerNameCopyWith<_$CheckingPlayerName> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PlayerNameChangeCopyWith<$Res> {
  factory _$$PlayerNameChangeCopyWith(
          _$PlayerNameChange value, $Res Function(_$PlayerNameChange) then) =
      __$$PlayerNameChangeCopyWithImpl<$Res>;
  $Res call({String name});
}

/// @nodoc
class __$$PlayerNameChangeCopyWithImpl<$Res>
    extends _$PlayerSelectionStateCopyWithImpl<$Res>
    implements _$$PlayerNameChangeCopyWith<$Res> {
  __$$PlayerNameChangeCopyWithImpl(
      _$PlayerNameChange _value, $Res Function(_$PlayerNameChange) _then)
      : super(_value, (v) => _then(v as _$PlayerNameChange));

  @override
  _$PlayerNameChange get _value => super._value as _$PlayerNameChange;

  @override
  $Res call({
    Object? name = freezed,
  }) {
    return _then(_$PlayerNameChange(
      name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PlayerNameChange implements PlayerNameChange {
  const _$PlayerNameChange(this.name);

  @override
  final String name;

  @override
  String toString() {
    return 'PlayerSelectionState.nameChange(name: $name)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PlayerNameChange &&
            const DeepCollectionEquality().equals(other.name, name));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(name));

  @JsonKey(ignore: true)
  @override
  _$$PlayerNameChangeCopyWith<_$PlayerNameChange> get copyWith =>
      __$$PlayerNameChangeCopyWithImpl<_$PlayerNameChange>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nameInvalid,
    required TResult Function(String name) nameAvailable,
    required TResult Function(String name) nameUnavailable,
    required TResult Function(String name) checkingName,
    required TResult Function(String name) nameChange,
    required TResult Function() playerCreated,
    required TResult Function(int id) playerExists,
  }) {
    return nameChange(name);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? nameInvalid,
    TResult Function(String name)? nameAvailable,
    TResult Function(String name)? nameUnavailable,
    TResult Function(String name)? checkingName,
    TResult Function(String name)? nameChange,
    TResult Function()? playerCreated,
    TResult Function(int id)? playerExists,
  }) {
    return nameChange?.call(name);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nameInvalid,
    TResult Function(String name)? nameAvailable,
    TResult Function(String name)? nameUnavailable,
    TResult Function(String name)? checkingName,
    TResult Function(String name)? nameChange,
    TResult Function()? playerCreated,
    TResult Function(int id)? playerExists,
    required TResult orElse(),
  }) {
    if (nameChange != null) {
      return nameChange(name);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PlayerNameInvalid value) nameInvalid,
    required TResult Function(PlayerNameAvailable value) nameAvailable,
    required TResult Function(PlayerNameUnavailable value) nameUnavailable,
    required TResult Function(CheckingPlayerName value) checkingName,
    required TResult Function(PlayerNameChange value) nameChange,
    required TResult Function(PlayerCreated value) playerCreated,
    required TResult Function(PlayerExists value) playerExists,
  }) {
    return nameChange(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(PlayerNameInvalid value)? nameInvalid,
    TResult Function(PlayerNameAvailable value)? nameAvailable,
    TResult Function(PlayerNameUnavailable value)? nameUnavailable,
    TResult Function(CheckingPlayerName value)? checkingName,
    TResult Function(PlayerNameChange value)? nameChange,
    TResult Function(PlayerCreated value)? playerCreated,
    TResult Function(PlayerExists value)? playerExists,
  }) {
    return nameChange?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PlayerNameInvalid value)? nameInvalid,
    TResult Function(PlayerNameAvailable value)? nameAvailable,
    TResult Function(PlayerNameUnavailable value)? nameUnavailable,
    TResult Function(CheckingPlayerName value)? checkingName,
    TResult Function(PlayerNameChange value)? nameChange,
    TResult Function(PlayerCreated value)? playerCreated,
    TResult Function(PlayerExists value)? playerExists,
    required TResult orElse(),
  }) {
    if (nameChange != null) {
      return nameChange(this);
    }
    return orElse();
  }
}

abstract class PlayerNameChange implements PlayerSelectionState {
  const factory PlayerNameChange(final String name) = _$PlayerNameChange;

  String get name => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$PlayerNameChangeCopyWith<_$PlayerNameChange> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PlayerCreatedCopyWith<$Res> {
  factory _$$PlayerCreatedCopyWith(
          _$PlayerCreated value, $Res Function(_$PlayerCreated) then) =
      __$$PlayerCreatedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PlayerCreatedCopyWithImpl<$Res>
    extends _$PlayerSelectionStateCopyWithImpl<$Res>
    implements _$$PlayerCreatedCopyWith<$Res> {
  __$$PlayerCreatedCopyWithImpl(
      _$PlayerCreated _value, $Res Function(_$PlayerCreated) _then)
      : super(_value, (v) => _then(v as _$PlayerCreated));

  @override
  _$PlayerCreated get _value => super._value as _$PlayerCreated;
}

/// @nodoc

class _$PlayerCreated implements PlayerCreated {
  const _$PlayerCreated();

  @override
  String toString() {
    return 'PlayerSelectionState.playerCreated()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PlayerCreated);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nameInvalid,
    required TResult Function(String name) nameAvailable,
    required TResult Function(String name) nameUnavailable,
    required TResult Function(String name) checkingName,
    required TResult Function(String name) nameChange,
    required TResult Function() playerCreated,
    required TResult Function(int id) playerExists,
  }) {
    return playerCreated();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? nameInvalid,
    TResult Function(String name)? nameAvailable,
    TResult Function(String name)? nameUnavailable,
    TResult Function(String name)? checkingName,
    TResult Function(String name)? nameChange,
    TResult Function()? playerCreated,
    TResult Function(int id)? playerExists,
  }) {
    return playerCreated?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nameInvalid,
    TResult Function(String name)? nameAvailable,
    TResult Function(String name)? nameUnavailable,
    TResult Function(String name)? checkingName,
    TResult Function(String name)? nameChange,
    TResult Function()? playerCreated,
    TResult Function(int id)? playerExists,
    required TResult orElse(),
  }) {
    if (playerCreated != null) {
      return playerCreated();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PlayerNameInvalid value) nameInvalid,
    required TResult Function(PlayerNameAvailable value) nameAvailable,
    required TResult Function(PlayerNameUnavailable value) nameUnavailable,
    required TResult Function(CheckingPlayerName value) checkingName,
    required TResult Function(PlayerNameChange value) nameChange,
    required TResult Function(PlayerCreated value) playerCreated,
    required TResult Function(PlayerExists value) playerExists,
  }) {
    return playerCreated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(PlayerNameInvalid value)? nameInvalid,
    TResult Function(PlayerNameAvailable value)? nameAvailable,
    TResult Function(PlayerNameUnavailable value)? nameUnavailable,
    TResult Function(CheckingPlayerName value)? checkingName,
    TResult Function(PlayerNameChange value)? nameChange,
    TResult Function(PlayerCreated value)? playerCreated,
    TResult Function(PlayerExists value)? playerExists,
  }) {
    return playerCreated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PlayerNameInvalid value)? nameInvalid,
    TResult Function(PlayerNameAvailable value)? nameAvailable,
    TResult Function(PlayerNameUnavailable value)? nameUnavailable,
    TResult Function(CheckingPlayerName value)? checkingName,
    TResult Function(PlayerNameChange value)? nameChange,
    TResult Function(PlayerCreated value)? playerCreated,
    TResult Function(PlayerExists value)? playerExists,
    required TResult orElse(),
  }) {
    if (playerCreated != null) {
      return playerCreated(this);
    }
    return orElse();
  }
}

abstract class PlayerCreated implements PlayerSelectionState {
  const factory PlayerCreated() = _$PlayerCreated;
}

/// @nodoc
abstract class _$$PlayerExistsCopyWith<$Res> {
  factory _$$PlayerExistsCopyWith(
          _$PlayerExists value, $Res Function(_$PlayerExists) then) =
      __$$PlayerExistsCopyWithImpl<$Res>;
  $Res call({int id});
}

/// @nodoc
class __$$PlayerExistsCopyWithImpl<$Res>
    extends _$PlayerSelectionStateCopyWithImpl<$Res>
    implements _$$PlayerExistsCopyWith<$Res> {
  __$$PlayerExistsCopyWithImpl(
      _$PlayerExists _value, $Res Function(_$PlayerExists) _then)
      : super(_value, (v) => _then(v as _$PlayerExists));

  @override
  _$PlayerExists get _value => super._value as _$PlayerExists;

  @override
  $Res call({
    Object? id = freezed,
  }) {
    return _then(_$PlayerExists(
      id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$PlayerExists implements PlayerExists {
  const _$PlayerExists(this.id);

  @override
  final int id;

  @override
  String toString() {
    return 'PlayerSelectionState.playerExists(id: $id)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PlayerExists &&
            const DeepCollectionEquality().equals(other.id, id));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(id));

  @JsonKey(ignore: true)
  @override
  _$$PlayerExistsCopyWith<_$PlayerExists> get copyWith =>
      __$$PlayerExistsCopyWithImpl<_$PlayerExists>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nameInvalid,
    required TResult Function(String name) nameAvailable,
    required TResult Function(String name) nameUnavailable,
    required TResult Function(String name) checkingName,
    required TResult Function(String name) nameChange,
    required TResult Function() playerCreated,
    required TResult Function(int id) playerExists,
  }) {
    return playerExists(id);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? nameInvalid,
    TResult Function(String name)? nameAvailable,
    TResult Function(String name)? nameUnavailable,
    TResult Function(String name)? checkingName,
    TResult Function(String name)? nameChange,
    TResult Function()? playerCreated,
    TResult Function(int id)? playerExists,
  }) {
    return playerExists?.call(id);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nameInvalid,
    TResult Function(String name)? nameAvailable,
    TResult Function(String name)? nameUnavailable,
    TResult Function(String name)? checkingName,
    TResult Function(String name)? nameChange,
    TResult Function()? playerCreated,
    TResult Function(int id)? playerExists,
    required TResult orElse(),
  }) {
    if (playerExists != null) {
      return playerExists(id);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PlayerNameInvalid value) nameInvalid,
    required TResult Function(PlayerNameAvailable value) nameAvailable,
    required TResult Function(PlayerNameUnavailable value) nameUnavailable,
    required TResult Function(CheckingPlayerName value) checkingName,
    required TResult Function(PlayerNameChange value) nameChange,
    required TResult Function(PlayerCreated value) playerCreated,
    required TResult Function(PlayerExists value) playerExists,
  }) {
    return playerExists(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(PlayerNameInvalid value)? nameInvalid,
    TResult Function(PlayerNameAvailable value)? nameAvailable,
    TResult Function(PlayerNameUnavailable value)? nameUnavailable,
    TResult Function(CheckingPlayerName value)? checkingName,
    TResult Function(PlayerNameChange value)? nameChange,
    TResult Function(PlayerCreated value)? playerCreated,
    TResult Function(PlayerExists value)? playerExists,
  }) {
    return playerExists?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PlayerNameInvalid value)? nameInvalid,
    TResult Function(PlayerNameAvailable value)? nameAvailable,
    TResult Function(PlayerNameUnavailable value)? nameUnavailable,
    TResult Function(CheckingPlayerName value)? checkingName,
    TResult Function(PlayerNameChange value)? nameChange,
    TResult Function(PlayerCreated value)? playerCreated,
    TResult Function(PlayerExists value)? playerExists,
    required TResult orElse(),
  }) {
    if (playerExists != null) {
      return playerExists(this);
    }
    return orElse();
  }
}

abstract class PlayerExists implements PlayerSelectionState {
  const factory PlayerExists(final int id) = _$PlayerExists;

  int get id => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$PlayerExistsCopyWith<_$PlayerExists> get copyWith =>
      throw _privateConstructorUsedError;
}
